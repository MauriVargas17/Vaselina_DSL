/*
 * generated by Xtext 2.27.0-SNAPSHOT
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.vaselina.AbstractMethodCall
import org.xtext.example.mydsl.vaselina.BodyStatement
import org.xtext.example.mydsl.vaselina.BrkStr
import org.xtext.example.mydsl.vaselina.DoWhileExpression
import org.xtext.example.mydsl.vaselina.FuncCall
import org.xtext.example.mydsl.vaselina.FuncDefinition
import org.xtext.example.mydsl.vaselina.FuncParameter
import org.xtext.example.mydsl.vaselina.IfExpression
import org.xtext.example.mydsl.vaselina.StdFunction
import org.xtext.example.mydsl.vaselina.StringRef
import org.xtext.example.mydsl.vaselina.arrayRef
import org.xtext.example.mydsl.vaselina.arrayRefs
import org.xtext.example.mydsl.vaselina.arrayDimension
import org.xtext.example.mydsl.vaselina.boolRef
import org.xtext.example.mydsl.vaselina.numRef
import org.xtext.example.mydsl.vaselina.varAssignment
import org.xtext.example.mydsl.vaselina.varDeclared
import org.xtext.example.mydsl.vaselina.varExpression
import org.xtext.example.mydsl.vaselina.varRef 
import org.xtext.example.mydsl.vaselina.varRefs 
import org.xtext.example.mydsl.vaselina.varReturn
import org.xtext.example.mydsl.vaselina.VaselinaProgram
import org.xtext.example.mydsl.vaselina.doubleRef
import org.xtext.example.mydsl.vaselina.Or
import org.xtext.example.mydsl.vaselina.Equality
import org.xtext.example.mydsl.vaselina.And
import org.xtext.example.mydsl.vaselina.Comparison
import org.xtext.example.mydsl.vaselina.PlusOrMinus
import org.xtext.example.mydsl.vaselina.MulOrDiv
import org.xtext.example.mydsl.vaselina.Module
import org.xtext.example.mydsl.vaselina.Not
import org.xtext.example.mydsl.vaselina.Inside
import org.xtext.example.mydsl.vaselina.ReturnDeclaration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class VaselinaGenerator extends AbstractGenerator {

	
	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val path = input.getURI.path
		val filepath = path.toString.substring(path.lastIndexOf('/') + 1);
		val filename = filepath.replace(".dsl", "")

		var java = input.allContents.filter(typeof(VaselinaProgram))
		java.forEach[item|fsa.generateFile(filename + '.java', compileJava(item, filename))]
		
	}

	/**
	 * 1. when xtext attr name has var, hat^ can be used as a wild card ex) var+=varDeclared* => dsl.^var
	 * 2. xtend doesn't have break and continue
	 * 3. xtend can't return Object.
	 */
	def compileJava(VaselinaProgram dsl, String fileName) {
		'''
			/**
			*
			This java file is generated from «toTitleCase(fileName)». 
			This is generated code, do not modify it.
			*/
			
			public class «toTitleCase(fileName.replace("-","").replace(".cum", ""))»{	
			
				«IF dsl.global !== null»
					«FOR param : dsl.global» 
						«compilevarDeclaredGlobal(param)»
					«ENDFOR»
				«ENDIF»
			
				«FOR func : dsl.func»
					private static «returnType(func)» «func.name»(«compileArgDeclaration2(func.args)»){
					«FOR body : func.body»						
						«compileBodyStatement(body)»
					«ENDFOR»
					}
				«ENDFOR»
				
				public static void main(String args[]){
				
				System.out.println("Inspired on our dear friend: Mateo Velasco");				
				«FOR body : dsl.main.body»
					«compileBodyStatement(body)»
				«ENDFOR»
				}
				«stdfunctionModelBuilder»
				
			}
			
		'''
	}
	
	def compileBodyStatement(BodyStatement b) {
		switch (b) {
			AbstractMethodCall: compileAbstractMethod(b)
			varAssignment: compileVarAssignment(b)
			//remove varExpression from body
			//varExpression: compileVarExpression(b)
			IfExpression: compileIfExpression(b)
			DoWhileExpression: compileDoWhileExpression(b)
			BrkStr: brkStr(b)
			varDeclared: compilevarDeclared(b)
			varReturn: returnStr(b)
			//ReturnDeclaration: returnDeclaration(b)
		}
	}
	
	def returnDeclaration(ReturnDeclaration r){
		
	}

	def returnType(FuncDefinition d) {
		var buf = "void"
		var flag = true

		for (p : d.body) {
			if (!(p instanceof ReturnDeclaration) && flag) {
				if (p instanceof varReturn) {
					val t = typeReturn(p.rtn)
					buf = typeName(t)
				} else if (p instanceof IfExpression){
					for (pp : p.then){
						if (pp instanceof varReturn){
							val tt = typeReturn(pp.rtn)
							buf = typeName(tt)
						}
					}
				}
			} else if (p instanceof ReturnDeclaration){
				buf = p.rtnType.typeName
				flag = false
			}
			
		}

		return buf.replace(";;",";")
	}

	def TerminalTypeResolver(varExpression t) {
		var buf = ""

		if (t instanceof varRef) {
			val sb = t.varRef
			buf = sb.type
		}
		
		if (t instanceof StringRef) {
			buf = "strange"
		}
		
		if (t instanceof numRef) {
			buf = "numb"
		}
		
		if (t instanceof doubleRef) {
			buf = "dribble"
		}

		if (t instanceof arrayRef) {
			val sb = t.varRef
			buf = sb.type
		}

		return buf
	}

	def compilevarDeclaredGlobal(varDeclared p) {
		var buf = "static "
		var isDim = false
		if (p.dim.length != 0) {
			isDim = true
		}
		buf += typeName(p.type)
		buf += " " + p.name

		// String[] array = new String[10];
		// array index to be int
		if (isDim) {
			for (d : p.dim) {
				buf += "[]"
			}
			buf += " = new "
			buf += typeName(p.type)

			for (d : p.dim) {
				var dix = d.index
				if (dix instanceof numRef){
					buf += "[" + dix.value.toString + "]"
				}
				if (dix instanceof varRef){
					buf += "[" + dix.varRef.name.toString + "]"
				}
				

				if (p.dim.length == (p.dim.lastIndexOf(d) + 1)) {
					buf += ';'
				}
			}
		}

		if (!isDim) {
			if (p.type == "strange") {
				buf += " = \"\";"
			} else if (p.type == "bull") {
				buf += " = false;"
			} else if (p.type == "dribble"){
				buf += " = 0.0;"
			} else {
				buf += " = 0;"
			}
		}

		return buf
	}

	def compileArgDeclaration2(EList<FuncParameter> pl) {
		var buf = ""

		for (p : pl) {
			buf += typeName(p.type)

			buf += " " + p.name

			if (pl.length != (pl.lastIndexOf(p) + 1)) {
				buf += ','
			}
		}

		return buf
	}

	def compileArgDeclaration(EList<varDeclared> pl) {
		var buf = ""

		for (p : pl) {
			buf = typeName(p.type)

			if (p.dim.length != 0) {
				for (d : p.dim) {
					buf += "[]"
				}
			}
			buf += " " + p.name

			if (pl.length != (pl.lastIndexOf(p) + 1)) {
				buf += ','
			}
		}

		return buf
	}

	def compilevarDeclared(varDeclared p) {
		var buf = ""
		var isDim = false
		if (p.dim.length != 0) {
			isDim = true
		}
		buf = typeName(p.type)
		buf += " " + p.name

		// String[] array = new String[10];
		// array index to be int
		if (isDim) {
			for (d : p.dim) {
				buf += "[]"
			}
			buf += " = new "
			buf += typeName(p.type)

			for (d : p.dim) {
				var dix = d.index
				if (dix instanceof numRef){
					buf += "[" + dix.value.toString + "]"
				}
				if (dix instanceof varRef){
					buf += "[" + dix.varRef.name.toString + "]"
				}
				

				if (p.dim.length == (p.dim.lastIndexOf(d) + 1)) {
					buf += ';'
				}
			}
		}

		if (!isDim) {
			if (p.type == "strange") {
				buf += " = \"\";"
			} else if (p.type == "bull") {
				buf += " = false;"
			} else if (p.type == "dribble"){
				buf += " = 0.0;"
			} else {
				buf += " = 0;"
			}
		}

		return buf
	}

	def returnStr(varReturn b) {
		var buf = 'return '

		buf += TerminalMatchFinder(b.rtn)
		buf += ';'

		return buf.replace(";;", ";")
	}
	
	def TerminalMatchFinder(varExpression t) {
		var buf = ""

		if (t instanceof Inside) {
			buf = "(" + t.inside.toString() + ")"
		}
		if (t instanceof numRef) {
			buf = t.value.toString()
		}
		
		if (t instanceof Not) {
			buf = "!"+t.expression.toString
		}
		
		if (t instanceof arrayRef) {
			buf = t.varRef.name

			if (t.dim.length != 0) {
				
				for (d : t.dim) {
					var dix = d.index
				if (dix instanceof numRef){
					buf += "[" + dix.value.toString + "]"
				}
				if (dix instanceof varRef){
					buf += "[" + dix.varRef.name.toString + "]"
				}
				

				}
			}
			
		}
		if (t instanceof varRef) {
			buf = t.varRef.name
		}

		if (t instanceof StringRef) {
			buf = '\"' + t.value + '\"'
		}
		
		if (t instanceof boolRef) {
			buf = t.varRef.replace("...","")
		}
		
		if (t instanceof doubleRef) {
			buf = t.value.integer + '.' + t.value.decimal
		}
		
		if(buf==""){
			buf = t.compileVarExpression
		}

		return buf
	}
	//Brought from validator
	def String typeReturn(varExpression t) {
		var rtn = ""
		switch (t) {
			Or: if(t.left.typeReturn.equals("bull") && t.right.typeReturn.equals("bull")) {rtn="bull"}
			And: if(t.left.typeReturn.equals("bull") && t.right.typeReturn.equals("bull")) {rtn="bull"}
			Equality: if(t.left.typeReturn.equals("bull") && t.right.typeReturn.equals("bull") || t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("numb")) {rtn="bull"}
			Comparison: if(t.left.typeReturn.equals("dribble") && t.right.typeReturn.equals("dribble") || t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("numb")) {rtn="bull"}
			PlusOrMinus: if(t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("numb")) {rtn="numb"} else if (t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("dribble")
			||t.left.typeReturn.equals("dribble") && t.right.typeReturn.equals("dribble")||t.left.typeReturn.equals("dribble") && t.right.typeReturn.equals("numb")) {rtn="dribble"} 
			else if (t.left.typeReturn.equals("strange") && t.right.typeReturn.equals("numb") || t.left.typeReturn.equals("strange") && t.right.typeReturn.equals("strange") || t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("strange")) {rtn="strange"} 
			MulOrDiv: if(t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("numb")) {rtn="numb"} else if (t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("dribble")
			||t.left.typeReturn.equals("dribble") && t.right.typeReturn.equals("dribble")||t.left.typeReturn.equals("dribble") && t.right.typeReturn.equals("numb")) {rtn="dribble"}
			Not: if(t.expression.typeReturn.equals("bull")){rtn="bull"}
			Module: if(t.left.typeReturn.equals("numb") && t.right.typeReturn.equals("numb")) {rtn="numb"} 
			numRef: rtn = "numb"
			StringRef: rtn = "strange"
			doubleRef: rtn = "dribble"
			boolRef: rtn = "bull"
			varRef: if(true){var w = t.varRef if(w instanceof varDeclared){ 
				if(w.scope.equals("boxes")){rtn += "array of " 
					var i = 1
					while (i < w.dim.length){
						rtn += "array of "
						i++
					}
					rtn += t.varRef?.type} else {rtn = t.varRef?.type}}else{rtn = t.varRef?.type}}
			arrayRef: rtn = t.varRef?.type
			Inside: rtn = t.inside.typeReturn
			StdFunction: if(getStdReturnType(t.name).contains("S")){rtn="strange"} 
			else if(getStdReturnType(t.name).contains("N")){rtn="numb"}
			else if(getStdReturnType(t.name).contains("O")){rtn="bull"}
			else if(getStdReturnType(t.name).contains("R")){rtn="numb"}
			FuncCall: for(f: t.func.body){if(f instanceof varReturn){rtn=f.rtn.typeReturn}}
		}
		return rtn
	}
	//Brought from validator
	def getStdReturnType(String d) {
		var buff = ""
		switch d {
			case "display": buff = ""
			case "printstr": buff = ""
			case "strjoin": buff = "S"
			case "strsplit": buff = "SS"
			case "numtostr": buff = "S"
			case "equals": buff = "OO" // num or string or bool
			case "getargs" : buff = "N"
			case "length" : buff = "N"
		}
		return buff
	}

	def String compileVarExpression(varExpression r) {
		var buf = new StringBuilder()

		if (r instanceof Or) {
			buf.append(compileVarExpression(r.left))
			var opStr = r.getOp()
				
				buf.append(" " + opStr + " ")
				val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
		else if (r instanceof And) {
			buf.append(compileVarExpression(r.left))
			var opStr = r.op
				
				buf.append(" " + opStr + " ")
				val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
		 else if (r instanceof Equality) {
			buf.append(compileVarExpression(r.left))
			var opStr = r.op
				
				buf.append(" " + opStr + " ")
				val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
		else if (r instanceof Comparison) {
			buf.append(compileVarExpression(r.left))
			var opStr = r.op
				
				buf.append(" " + opStr + " ")
				val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
		else if (r instanceof PlusOrMinus) {
			buf.append(compileVarExpression(r.left))
			var opStr = ""
			if (r.left.typeReturn.equals("strange") && r.right.typeReturn.equals("numb") || r.left.typeReturn.equals("strange") && r.right.typeReturn.equals("strange") || r.left.typeReturn.equals("numb") && r.right.typeReturn.equals("strange")) {
				opStr = "+"
			} else {
				opStr = r.op
				
			}
			buf.append(" " + opStr + " ")
			val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
		else if (r instanceof MulOrDiv) {
			buf.append(compileVarExpression(r.left))
			var opStr = r.op
				
				buf.append(" " + opStr + " ")
				val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
			
		else if (r instanceof Module) {
			buf.append(compileVarExpression(r.left))
			var opStr = r.op
				
				buf.append(" " + opStr + " ")
				val a = r.right
				if (a instanceof varExpression){
					buf.append(compileVarExpression(a))
				}
			}
		else if (r instanceof Not) {
			buf.append("!")
			buf.append(r.expression.compileVarExpression)
		
				
			}
			
		else if (r instanceof Inside) {
			
			buf.append("(" + r.inside.compileVarExpression + ")")
				
			}	
			
		else if (r instanceof StringRef || r instanceof numRef || r instanceof doubleRef || r instanceof boolRef || r instanceof arrayRef ||r instanceof varRef) {
			
			buf.append(TerminalMatchFinder(r))
				
			}
		
				
		else if (r instanceof AbstractMethodCall) {

					var func = compileAbstractMethod(r)
					if (r.eContainer instanceof IfExpression || r.eContainer instanceof DoWhileExpression) {
						func = func.replace(";", "")
					}
					buf.append(func)
				}
		

//		if (isColon(r)) {
//			buf.append(";")
//		}

		return buf.toString.replace(";;", ";")
	}
	
	def compileVarAssignment(varAssignment v){
		var buf = ""
		buf = '''«varName(v)»'''
		var vrbl = v.variable
		
		if(vrbl instanceof arrayRefs){
			var aD = vrbl.dims
			for (d: aD){
				var dix = d.index
				if (dix instanceof numRef){
					buf += '[' + dix.value + ']'
				}
				if (dix instanceof varRef){
					buf += '[' + dix.varRef.name.toString + ']'
				}
				
			}	
		}
		buf += "="
		buf += v.expr.compileVarExpression
		buf += ";"
		return buf.toString.replace(";;", ";")
		
	}

	def compileFunction(FuncCall s) {
		var buf = ""
		buf = '''«funcName(s)»('''

		for (p : s.args) {
			if (p instanceof varRef) {
				buf += p.varRef.name

				if (s.args.length != (s.args.lastIndexOf(p) + 1)) {
					buf += ','
				}
			}
		// Is it needed to develop for ArrayRef? 
		}
		buf += ')'

		if (isColon(s)) {
			buf += ";"
		}

		return buf
	}

	def compileAbstractMethod(AbstractMethodCall r) {
		switch (r) {
			StdFunction: compileStdFunction(r)
			FuncCall: compileFuncCall(r)
		}
	}

	def String compileFuncCall(FuncCall s) {
		var buf = ""
		buf = '''«funcName(s)»('''

		for (p : s.args) {
			buf += compileArgResolver(p)

			if (s.args.length != (s.args.lastIndexOf(p) + 1)) {
				buf += ','
			}
		}
		buf += ')'

		if (isColon(s)) {
			buf += ";"
		}

		return buf
	}

	def compileArgResolver(varExpression p) {
		var buf = ""
		
		buf = compileVarExpression(p)
		return buf
	}

	def String compileStdFunction(StdFunction s) {
		var buf = ""
		buf = '''«s.name»('''

		for (p : s.args) {
			buf += compileArgResolver(p)

			if (s.args.length != (s.args.lastIndexOf(p) + 1)) {
				buf += ','
			}
		}
		buf += ')'

		if (isColon(s)) {
			buf += ";"
		}

		return buf
	}

	def compileIfExpression(IfExpression r) {
		val buf = new StringBuilder()

		buf.append("if(")
		buf.append(compileVarExpression(r.ifconditon))
		buf.append("){\n")
		for (t : r.then) {
			buf.append(compileBodyStatement(t))
		}

		if (r.^else.length !== 0) {
			buf.append("}else{\n")
			for (t : r.^else) {
				buf.append(compileBodyStatement(t))
			}
		}

		buf.append("}\n")

		return buf.toString
	}

	def compileDoWhileExpression(DoWhileExpression r) {
		val buf = new StringBuilder()

		buf.append("while(")
		buf.append(compileVarExpression(r.loopConditon))
		buf.append("){\n")

		for (t : r.body) {
			buf.append(compileBodyStatement(t))
		}

		buf.append("}\n")

		return buf.toString
	}

	/**
	 * Util Area
	 */
	def String typeName(String s) {
		var buf = ""
		switch (s) {
			case "numb": buf = '''int'''
			case "bull": buf = '''boolean'''
			case "strange": buf = '''String'''
			case "dribble": buf = '''double'''
		}
		return buf
	}

	def String brkStr(BrkStr r) {
		"break;"
	}

	def funcName(FuncCall s) {
		val funcCrossRef = s.func
		var funcname = funcCrossRef.name
		return funcname
	}
	
	def varName(varAssignment v){
		val varCrossRef = v.variable
		var varname = ""
		if (varCrossRef instanceof varRefs){
			varname = varCrossRef.vaRefs.name
		} else if (varCrossRef instanceof arrayRefs){
			varname = varCrossRef.arrRefs.name
		}
		
		return varname
	}

	def Boolean isColon(EObject s) {
		var isColon = true

		if (s.eContainer instanceof IfExpression || s.eContainer instanceof DoWhileExpression) {
			if (s.eContainingFeature.name.equals("ifconditon") || s.eContainingFeature.name.equals("loopConditon")) {
				isColon = false
			}
			if (s.eContainer.eContainer instanceof IfExpression ||
				s.eContainer.eContainer instanceof DoWhileExpression) {
				if (s.eContainer.eContainingFeature.name.equals("ifconditon") ||
					s.eContainer.eContainingFeature.name.equals("loopConditon")) {
					isColon = false
				}
			}
		}
		
		if(s.eContainer instanceof FuncCall || s.eContainer instanceof StdFunction) {
			isColon = false
		}
		if(s.eContainer instanceof varExpression) {
			isColon = false
		}
		return isColon
	}

	def String toTitleCase(String input) {
		val titleCase = new StringBuilder()
		var isFirst = true

		for (c : input.toCharArray()) {
			var ch = c
			if (isFirst) {
				ch = Character.toTitleCase(ch);
				isFirst = false;
			} else {
				ch = Character.toLowerCase(ch);
			}

			titleCase.append(ch);
		}
		return titleCase.toString();
	}

	def String stdfunctionModelBuilder() {
		val buf = new StringBuilder()

		buf.append("\n//Standard Function ======================================================\n")
		buf.append("private static void printstr(String a){ System.out.println(a); }\n")
		buf.append("private static String strjoin(String a, String b){ a = a.concat(b); return a; }\n")
		buf.append("private static String[] strsplit(String a, String b){ String[] rtn = a.split(b); return rtn; }\n")
		buf.append("private static String anytostr(Object a){ String rtn = String.valueOf(a); return rtn; }\n")
		buf.append("private static void display(Object a){ System.out.print(a); }\n")
		buf.append("private static boolean equals(Object a, Object b){ return a.equals(b); }\n")
		buf.append("private static int length(Object a){ return a.length; }\n")

		// main String arg[] to Map 
//		buf.append("private static void init(String[] args) {\n")
//		buf.append("for (String arg : args) {\n")
//		buf.append("String[] ag = arg.split(\"/\");\n")
//		buf.append("map.put(ag[0], ag[1]);}}\n")

		return buf.toString()
	}

}